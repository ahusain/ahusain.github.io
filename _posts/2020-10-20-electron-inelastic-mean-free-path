---
title: 'Inelastic Electron Mean Free Path in Solids'
date: 2020-10-20
permalink: /posts/2020/10/electron-inelastic-mean-free-path/
tags:
  - electron beam 
  - widget
  - calculator
  - inelastic
  - scattering
---

When dealing with electron diffraction within an electron microscope, it is often useful to have a quick converter to convert between the beam energy, angles, and reciprocal lattice units (r.l.u.). Below is a simple calculator that converts between electron beam energies, angles, and momentum transfer. For added benefit, there is also a lattice parameter option to present the momentum transfer in reciprocal lattice units where $1\textrm{ r.l.u.} = 2\pi/a$ and $a$ is the lattice parameter.

{% include trinket-open %}
import numpy as np
import math as math
import matplotlib.pyplot as plt

def log(x):
  y = np.array(x)
  try:
    x[1]
  except:
    y = math.log(x)
    return y
  for i,val in enumerate(x):
    y[i] = log(val)
  return y
  
def calc_IMFP_vector(Z, A, frac, alpha, beta, rho, E0):
  """
  Z = Vector of atomic numbers Z
  A = Vector of atomic weights A
  frac = Vector of compound fractions (needs to sum to 1)
  alpha = Incident-convergence semi-angle alpha (mrad) 
  beta = EELS collection semi-angle beta (mrad)
  rho = Enter specimen density rho (g/cm3)
  E0 = Incident energy E0 (keV)
  """
  alpha = alpha*1.00
  beta  = beta*1.00
  rho   = rho*1.00
  E0    = E0*1.00
  Z = np.array(Z)
  A = np.array(A)
  frac = np.array(frac)
  
  output ={}
  output["E0"] = E0
  
  numElem = len(Z);
  F = (1+E0/1022)/(1+E0/511)**2;
  Fg= (1+E0/1022)/(1+E0/511);
  TGT = 2*Fg*E0;
  
  a2 = alpha**2;
  b2 = beta**2;
  
  #calculate effective atomic number
  Zef = np.sum((frac*Z**1.3))/np.sum((frac*Z**0.3));
  Aef = np.sum((frac*A**1.3))/np.sum((frac*A**0.3));
  
  
  # Iakoubovskii et al.(1988)
  qE2 = (5.5*rho**0.3/(F*E0))**2;
  qc2 = 400;
  coeff = (11*rho**0.3)/(200*F*E0);
  num = (a2 + b2 + 2*qE2 + np.abs(a2-b2))*qc2;
  den = (a2 + b2 + 2*qc2 + np.abs(a2-b2))*qE2;
  LiI = 1/(coeff*log(num/den)); # Iakoubovskii original
  qE2g = (5.5*rho**0.3/(Fg*E0))**2; # correction to thetaE
  num2 = (a2 + b2 + 2*qE2g + np.abs(a2-b2))*qc2;
  den2 = (a2 + b2 + 2*qc2 + np.abs(a2-b2))*qE2g;
  LiI2 = 1/(coeff*log(num2/den2)); # Iakoubovskii revised
  
  output["IMFP(Iakoubovskii&,2008)"] = LiI
  output["IMFP(Iakoubovskii revised)"] = LiI2
  
  # calculation of convergence correction
  e=13.5*Zef/2; # Koppe approximation for mean energy loss
  tgt=E0*(1.0+E0/1022.0)/(1.0+E0/511.0); # keV
  thetae=(e+1e-6)/tgt; # in mrad, avoid NaN for e=0
  a2=alpha*alpha*1e-6 + 1e-10;  #radians**2, avoiding inf for alpha=0
  b2=beta*beta*1e-6; #radians**2
  t2=thetae*thetae*1e-6; #radians**2
  eta1=np.sqrt((a2+b2+t2)**2-4.*a2*b2)-a2-b2-t2;
  eta2=2*b2*log(0.5/t2*(np.sqrt((a2+t2-b2)**2+4*b2*t2)+a2+t2-b2));
  eta3=2*a2*log(0.5/t2*(np.sqrt((b2+t2-a2)**2+4*a2*t2)+b2+t2-a2));
  eta=(eta1+eta2+eta3)/a2/log(4./t2);
  f1=(eta1+eta2+eta3)/2/a2/log(1.+b2/t2);
  f2=f1;
  if(alpha/beta>1):
      f2=f1*a2/b2;
  bstar=thetae*np.sqrt(np.exp(f2*log(1.+b2/t2))-1.); # mrad
  
  # Malis et al. (1988)
  Em = 7.6*Zef**0.36;
  LiM=106*F*E0/Em/log(2*bstar*E0/Em);
  output["IMFP(Malis et al.)"] = LiM
  
  
  # Jin & Li (2006) formula Em = 42.5Z**0.47 rho/A
  #bs =(log(num2/den2)*qE2)**0.5
  if(rho and Aef):
      Em = 42.5*Zef**0.47*rho/Aef;
      LiJL=106*F*E0/Em/log(2*bstar*E0/Em);
      output["IMFP(Jin & Li)"] = LiJL
      
  return output
    
Z = [12]
A = [24]
frac = [1]
alpha = 30
beta = 30
rho = 10
E0 = np.linspace(30,300,100)
my_dict = calc_IMFP_vector(Z=Z, A=A, frac=frac, alpha=alpha, beta=beta, rho=rho, E0=E0)  

plt.xlabel("Beam Energy (kV)")
plt.ylabel("Inelastic Mean Free Path (nm)")

for key in my_dict.keys():
  print key
  if "E0"==key: continue
  x = my_dict["E0"]
  y = my_dict[key]
  plt.plot(x,y, label=key, alpha=1)
plt.axis([0,300,0,200])


plt.show()
# y1 = my_dict["IMFP(Iakoubovskii&,2008)"]  
# y2 = my_dict["IMFP(Malis et al.)"]  
# #plt.fill_between(x=x,y1=ymax, y2=ymin, color="gray", alpha=0.7)

{% include trinket-close %}